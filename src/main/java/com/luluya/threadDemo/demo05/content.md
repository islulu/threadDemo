#锁的深入化#

1. 重入锁(又名 递归锁)
    同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响。
    且内层函数可以获取外层函数锁的状态，如果已经获取锁/释放锁 则不在进行对应操作（防止死锁）
    
    Synchronized重入锁:(重量级)（悲观锁）
    ReentrantLock重入锁:(轻量级)（悲观锁）
    
2. 读写锁（JUC包）
    两个线程同时读一个资源没有任何问题，允许多个线程能在同时读取共享资源。
    有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写。
    即：读-读能共存，读-写不能共存，写-写不能共存
    ReentrantReadWriteLock:

3. 悲观锁、乐观锁
    乐观锁:
        不会上锁。如果满足条件则操作，如果不满足条件则重试。
        在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。
        
        - version方式：
            在数据表中加上数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。
            当线程A更新数据值时，在读取数据同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。
            * 核心SQL语句
            update table set x=x+1, version=version+1 where id=#{id} and version=#{version};    
        
        - CAS操作方式：即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的 内存值，预期值，新值。
            当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。
            
    悲观锁:
        总是假设最坏的情况，每次取数据时都认为其他线程会修改，都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。
        可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。
    
4. 原子类
    Atomic：（乐观锁）
        java.util.concurrent.atomic包;原子类的小工具包,支持在单个变量上解除锁的线程安全编程
        原子变量类相当于一种泛化的volatile 变量，能够支持原子的和有条件的读-改-写操作。
        
        AtomicInteger表示一个int类型的值，并提供了get和set方法，这些Volatile类型的int变量在读取和写入上有着相同的内存语义。
        
        它还提供了一个原子的compareAndSet方法（如果该方法成功执行，那么将实现与读取/写入一个 volatile 变量相同的内存效果），以及原子的添加、递增和递减等方法。
        AtomicInteger 表面上非常像一个扩展的 Counter 类，但在发生竞争的情况下能提供更高的可伸缩性，因为它直接利用了硬件对并发的支持。
    
        如果同一个变量要被多个线程访问，则可以使用该包中的类
        AtomicBoolean
        AtomicInteger
        AtomicLong
        AtomicReference
    
    CAS无锁模式：Compare and Swap，即比较再交换。
        好处：
            第一，高并发下，性能优于有锁程序
            第二，不存在死锁情况
        CAS缺点：
            ABA问题：解决方法（原子引用类AtomicStampedReference，它可以通过控制变量值的版本来保证CAS的正确性。      
        
        *CAS算法的过程：
            内存值，预期值，新值
                v = 需要更新变量 主内存
                e = 期望值 本地内存
                n = 新值
                if(v==e){//主内存值与本地内存值一致
                    //没有被修改过
                    v=n;
                }else if(v!=e){//主内存值与本地内存值不一致
                    //已经被修改
                }    
            当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。
            失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。

5. 分布式锁
    如果想在不同的jvm中保证数据同步，使用分布式锁技术。
    缓存实现、 * Zookeeper分布式锁

7. 自旋锁 ：属于乐观锁。线程一直是running(加锁 --> 解锁)，死循环检测锁的标识位，机制不复杂 （CAS
   互斥锁 ：属于悲观锁。互斥等待、阻塞。线程会从sleep(加锁) --> running(解锁)，过程中有上下文的切换，cpu的抢占，信号的发送等开销
   
8. 公平锁：先进先出
   非公平锁：在等待锁的过程中，如果有任意新的线程妄图获取锁，都是有很大几率直接获取到锁的（即 不排队直接拿，失败再说
   
   都是基于锁内部维护的一个双向链表，表节点node的值 就是 每一个请求当前锁的线程。
   
   双向链表：
    
6. Disruptor（高性能的异步处理框架、并发编程框架
   采用 CAS无锁机制（乐观锁）、观察者模式、事件监听
   
    
   AQS -- Lock
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    