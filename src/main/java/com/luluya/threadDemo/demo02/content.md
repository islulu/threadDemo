#Java内存模型#
0. 线程三大特性：
    a. 原子性（保证数据一致、线程安全一部分
        一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行
    b. 可见性
        当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
    c. 有序性
        程序执行的顺序按照代码的先后顺序执行。

1. 多线程安全
    当多个线程同时共享，同一个全局变量或静态变量；
    - 做写操作时，可能发生数据冲突问题
    - 做读操作时，不会发生数据冲突问题
   解决方法：
    a,使用多线程之间同步synchronized/使用锁(lock)
        (只能让当前一个线程进行执行。代码执行完成后释放锁，让后才能让其他线程进行执行。

   多线程之间同步:当多个线程共享同一个资源,不会受到其他线程的干扰。

2. 同步
    同步的前提： 
        1，必须要有两个或者两个以上的线程 
        2，必须是多个线程使用同一个锁 
    必须保证同步中只能有一个线程在运行 
        好处：解决了多线程的安全问题 
        弊端：多个线程需要判断锁，较为消耗资源、抢锁的资源。

3. java内存模型
    共享内存模型：Java内存模型(简称JMM)
    JMM决定一个线程对共享变量的写入时,能对另一个线程可见。
    JMM定义线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。
    当多个线程同时访问一个数据的时候，可能本地内存没有及时刷新到主内存，所以就会发生线程安全问题。
    （本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。）

4. ThreadLocal(Test04
    设计目的：
        * 为了能够在当前线程中有属于自己的变量，并不是为了解决并发或者共享变量的问题
        
        threadLocal提高一个线程的局部变量，访问某个线程拥有自己局部变量。
        * 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。

    ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。

    ThreadLocal实现原理:
        ThreadLocal通过map集合
        Map.put(“当前线程”,值)；
    
    原理：
        每个Thread维护着一个ThreadLocalMap的引用
        ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储
        调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象
        调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象
        ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。
        
    避免内存泄露：
        由于一些操作导致延长了ThreadLocal的生命周期，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。
        解决方案：每次使用完ThreadLocal，都调用它的remove()方法，清除数据
    
    应用场景：
        通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。
        ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且对并发性处理效果更好。

5. 内置锁：互斥锁（使用synchronized关键字实现 (Test01，Test02
    * synchronized保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。
    会创建一个内存屏障，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都happens-before于随后获得这个锁的线程的操作。

    线程进入同步代码块之前自动获取到锁，代码块执行完成正常退出或代码块中抛出异常退出时会释放掉锁
    
    1. 同步代码块：锁的粒度更细；充当锁的对象：this/其它对象，更加灵活
              synchronized(对象)//这个对象可以为任意对象 
              { 
                  需要被同步的代码 
              } 

    2. 同步方法：所有访问状态变量的方法都必须进行同步；充当锁的对象：调用同步方法的对象
              就是将可能会发生线程安全问题的代码，给包括起来。
              synchronized(同一个数据){
                  可能会发生线程冲突问题
              }
    静态同步函数：
        方法上加上static关键字，使用synchronized 关键字修饰 或者使用类.class文件。
        静态的同步函数使用的锁是  该函数所属字节码文件对象
        可以用 getClass方法获取，也可以用当前  类名.class 表示。

    synchronized 修饰方法使用锁是当前this锁。
    synchronized 修饰静态方法使用锁是当前类的字节码文件

6. volatile关键字（Test05
    * 只有成员变量才能使用它
    线程间共享变量的可见性,不保证原子性
    * 仅能实现对原始变量(如boolen、 short 、int 、long等)操作的原子性，
      但需要特别注意， volatile不能保证复合操作的原子性，即使只是i++，实际上也是由多个原子操作组成，假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。

    volatile 关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存
    
    Java中为了加快程序的运行效率，对一些变量的操作通常是在该线程的寄存器或是CPU缓存上进行的，之后才会同步到主存中，
    而加了volatile修饰符的变量则是直接读写主存。

    volatile原理是基于CPU内存屏障指令实现的：

    使用条件:
        1. 对变量的写入操作不依赖变量的当前值，或者确保只有单个线程更新变量的值。
        2. 该变量没有包含在具有其他变量的不变式中。

    volatile特性:
        a,保证此变量对所有的线程的可见性（保证了新值能立即同步到主内存 & 每次使用前立即从主内存刷新
        b,禁止指令重排序优化
            volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，
                这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；
            指令重排序：CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。
        性能：volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。

7. volatile与Synchronized区别:
    1) synchronized保证可见性和原子性; volatile 有可见性，禁止重排序
    2) volatile是变量修饰符，仅能用于变量，而synchronized是一个方法或块的修饰符
           volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的，使用前需要先从主存中读取，so实现了可见性，
           对于n=n+1,n++操作时volatile关键字将失效，不能起到像synchronized一样的线程同步（原子性）的效果。
    3) volatile不需要加锁; 比synchronized更轻量级，并不会阻塞线程
    4) volatile标记的变量不会被编译器优化，synchronized标记的变量可被编译器优化（如编译器重排序的优化）
    5) volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； 
       synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住;
    
    6) 性能方面：
        synchronized关键字是防止多个线程同时执行一段代码，就会影响程序执行效率，
        volatile关键字在某些情况下性能要优于synchronized。
        但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。

8. 多线程死锁(Test03
    同步中嵌套同步,导致锁无法释放

9. 重排序（Test06
    一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的
    
    重排序对单线程运行是不会有任何问题，而多线程就不一定了，所以我们在多线程编程时就得考虑这个问题了。重排序对多线程会改变结果.
    目的：程序的执行结果不能被改变的情况下，提高并行度

    - 数据依赖性：针对单个处理器中执行的指令序列和单个线程中执行的操作
        编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。

    - as-if-serial：不管怎么重排序，（单线程）程序的执行结果不能被改变
        （单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果

    - 程序顺序规则（happens- before）
        程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。
        监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。
        volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。
        传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。
        
        注意：两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！
        * 仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。
    
    - 内存屏障
    
10. * 内存屏障（Memory Barrier）
    作用：
        保证特定操作的执行顺序。
        影响某些数据（或则是某条指令的执行结果）的内存可见性。
    
    插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。
    强制刷出各种CPU cache，如一个Write-Barrier（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。
       