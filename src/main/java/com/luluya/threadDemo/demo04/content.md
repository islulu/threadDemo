#线程池原理分析#
0.队列
    常用的队列主要有以下两种：
    （当然通过不同的实现方式，还可以延伸出很多不同类型的队列）
        先进先出（FIFO）：先插入的队列的元素也最先出队列。从某种程度上来说这种队列也体现了一种公平性。
        后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。
        
1. 并发包
    (计数器)CountDownLatch:（通过AQS里面的共享锁来实现
        类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。
        eg：有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。
        CountDownLatch是通过一个计数器来实现的，#计数器的初始值为线程的数量#。
        每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。
        
        countDownLatch.countDown();//计数器值每次减去1
        countDownLatch.await();// 減去为0,恢复任务继续执行
    
    (屏障)CyclicBarrier:
        CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。
            当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续。 
        CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到后，所有其它线程被唤醒前被执行。
        
    (计数信号量)Semaphore:
        Semaphore是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。
        Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。
        它的用法如下：
        availablePermits函数用来获取当前可用的资源数量
        wc.acquire(); //申请资源
        wc.release();// 释放资源
        
        
        // 创建一个计数阈值为5的信号量对象
        // 只能5个线程同时访问
        Semaphore semp = new Semaphore(5);
        try {
            // 申请许可
            semp.acquire();
            try {
                // 业务逻辑
            } catch (Exception e) {

            } finally {
                // 释放许可
                semp.release();
            }
        } catch (InterruptedException e) {

        }

2. 并发队列
    在并发队列上JDK提供了两套实现(无论哪种都继承自Queue)
    一个是以ConcurrentLinkedQueue为代表的高性能队列非阻塞
    一个是以BlockingQueue接口为代表的阻塞队列

    阻塞队列与非阻塞队:
        阻塞队列与普通队列的区别在于:
            当队列是空时，从队列中获取元素的操作将会被阻塞，直到其他的线程往空的队列插入新的元素。
            当队列是满时，往队列里添加元素的操作会被阻塞，直到其他的线程使队列重新变得空闲起来（从队列中移除一个或者多个元素，或者完全清空队列）
            
            1.ArrayDeque, （数组双端队列） 
            2.PriorityQueue, （优先级队列） 
            3.ConcurrentLinkedQueue, （基于链表的并发队列） 
            
            4.DelayQueue, （延期阻塞队列）（阻塞队列实现了BlockingQueue接口） 
            
            5.ArrayBlockingQueue, （基于数组的并发阻塞队列） 
            6.LinkedBlockingQueue, （基于链表的FIFO阻塞队列） 
            7.LinkedBlockingDeque, （基于链表的FIFO双端阻塞队列） 
            8.PriorityBlockingQueue, （带优先级的无界阻塞队列） 
            9.SynchronousQueue （并发同步阻塞队列）
    
    - 非阻塞队列： 
        ConcurrentLinkedQueue：
            是一个适用于高并发场景下的队列，通过无锁的方式实现了高并发状态下的高性能。
            通常ConcurrentLinkedQueue性能好于BlockingQueue.
            它是一个基于链接节点的无界线程安全队列。 该队列的元素遵循先进先出的原则（头是最先加入的，尾是最近加入的，该队列不允许null元素）
            重要方法:
                add()/offer():都是加入元素的方法(在ConcurrentLinkedQueue中这俩个方法没有任何区别)
                poll()/peek():都是取头元素节点，区别在于前者会删除元素，后者不会。
    
    - 阻塞队列：
        （在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒）

        BlockingQueue：（位于java.util.concurrent 包中(在Java5版本开始提供) 是线程安全的
            一个支持两个附加操作的队列。
            这两个附加的操作是：
                在队列空时，获取元素的线程会等待队列变为非空。
                当队列满时，存储元素的线程会等待队列可用。 
            
            阻塞队列常用于生产者和消费者的场景：生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。
            阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。
            
            被阻塞的情况主要有如下两种：
                1. 当队列满了的时候进行入队列操作（除非有另一个线程做了出队列操作
                2. 当队列空了的时候进行出队列操作（除非有另一个线程进行了入队列操作
            
            多消费者与多生产者，消费生产速度不一致导致需要开发者手动调整消费生产的相关细节且兼顾效率和线程安全则复杂度不低
            JUC则推出BlockingQueue
       
        - BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景：
        有边界即 它的容量是有限的，其初始化时必须指定其容量大小，容量大小一旦指定就不可改变。
        
        ArrayBlockingQueue：
            有边界的阻塞队列，内部实现是一个数组。以先进先出的方式存储数据

        LinkedBlockingQueue：
            队列大小的配置是可选的
                如果我们初始化时指定一个大小，它就是有边界的，
                如果不指定，它就是无边界的。说是无边界，其实是采用了默认大小为Integer.MAX_VALUE的容量 。它的内部实现是一个链表。
            以先进先出的方式存储数据

        PriorityBlockingQueue：
            没有边界的队列，它的排序规则和 java.util.PriorityQueue一样。（底层是在做扩容的）
                *注意，PriorityBlockingQueue中允许插入null对象。
            所有插入PriorityBlockingQueue的对象必须实现java.lang.Comparable接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。
            可从PriorityBlockingQueue获得一个迭代器Iterator，但这个迭代器并不保证按照优先级顺序进行迭代。
        
        SynchronousQueue：
            内部仅允许容纳一个元素。当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。

3. 线程池：
    （使用的是阻塞队列，因为核心线程执行需要耗时，所以需要用阻塞队列（用非阻塞队列，当核心线程未完成则会直接创建线程了）
    好处：
    a,降低资源消耗：通过重复利用已创建的线程 降低线程创建销毁造成的消耗
    b,提高响应速度：任务达到时，不需要等待线程创建即可立即执行
    c,提高线程管理性：无限制的创建线程会 消耗系统资源 降低系统稳定性，使用线程池可以进行统一分配、调优、监控
        * 要做到合理利用
    
    原理：
      Executors ThreadPoolExecutor
        corePoolSize：线程池核心线程数。最大运行线程数。当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，会把到达的任务放到缓存队列当中
        maximumPoolSize：线程池最大线程数，最大创建线程数。表示在线程池中最多能创建多少个线程
        
        核心线程数<=最大线程数
        
        keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。
        unit：keepAliveTime的时间单位，有7种取值。
       
    四种创建方式：
        newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
        newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
        newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。
        newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

    原理剖析：
        提交一个任务到线程池中，线程池的处理流程如下：
        1、判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。
        2、线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。
        3、判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

4. 自定义线程线程池
    如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；
    
    如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，
        若添加成功，则该任务会等待空闲线程将其取出去执行；
        若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；
    
    如果队列已经满了，则在总线程数不大于maximumPoolSize的前提下，则创建新的线程
    
    如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；
    
    如果线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；
    如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。

5. 如何合理的设置线程池大小
    1.	任务的性质：CPU密集型任务、IO密集型任务、混合型任务。
    2.	任务的优先级：高、中、低。
    3.	任务的执行时间：长、中、短。
    4.	任务的依赖性：是否依赖其他系统资源，如数据库连接等。
    
    CPU密集型：任务可以少配置线程数，大概和机器的cpu核数相当，这样可以使得每个线程都在执行任务
    IO密集型：大部分线程都阻塞，故需要多配置线程数，2*cpu核数
    
    最大线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目
    最大线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目
    线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。 

6. Callable
    继承Thread类/实现Runnable接口: 
        缺点: 在线程任务执行结束后，无法获取执行结果(采用共享变量或共享存储区以及线程通信的方式实现获得任务结果的目的)

    使用Callable和Future来实现获取任务结果的操作
        Callable用来执行任务，产生结果
        Future用来获得结果
    
    Future常用方法:
        V get() ：获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。
        V get(Long timeout , TimeUnit unit) ：获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。
        boolean isDone() ：如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。
        boolean isCanceller() ：如果任务完成前被取消，则返回true。
        boolean cancel(boolean mayInterruptRunning) ：
            (mayInterruptRunning参数表示是否中断执行中的线程。)
            如果任务还没开始，执行cancel(...)方法将返回false；
            如果任务已经启动，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果停止成功，返回true；
            当任务已经启动，执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回false；
            当任务已经完成，执行cancel(...)方法将返回false
    
    通过方法分析我们也知道实际上Future提供了3种功能：
    （1）能够中断执行中的任务
    （2）判断任务是否执行完成
    （3）获取任务执行完成后额结果。
    
