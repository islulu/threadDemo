#多线程基础#
0. 线程与进程的区别
    进程：是所有线程的集合，每一个线程是进程中的一条执行路径。
    线程：基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。

    大量的线程,会影响性能（操作系统需要在它们之间切换，更多的线程需要更多的内存空间，线程的中止需要考虑其对程序运行的影响。
    通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生。

1. 多线程应用场景
    作用：提高程序效率（eg:迅雷多线程下载、数据库连接池、分批发送短信等

2. 线程创建方式：
    a. 继承thread创建线程(Test01
        重写run方法（开启线程不是调用run方法，而是start方法
    b. 实现runnable创建线程(Test02
        重写run方法（开启线程不是调用run方法，而是start方法
        *_实现Runnable接口好（实现了接口还可继续继承
        调用start():启动线程
        调用run():使用实例调用方法
    c. 实现匿名内部类创建线程(Test03

5. 多线程五种状态
    新建状态、就绪状态、运行状态、阻塞状态、死亡状态
    a. 新建状态：new Thread(r)
        此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码
    b. 就绪状态：start()
        当线程对象调用start()方法即启动了线程，
        start()方法创建线程运行的系统资源，并调度线程运行run()方法。
        当start()方法返回后，线程就处于就绪状态。
    c. 运行状态：run()
        当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.
    d. 死亡状态：
        产生原因：
        1)run方法正常退出而自然死亡，
        2)一个未捕获的异常终止了run方法而使线程猝死。
        为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。
        如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的，或者线程死亡了，则返回false。
    e. *阻塞状态：
        产生原因：
        1>线程通过调用sleep方法进入睡眠状态；
        2>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；
        3>线程试图得到一个锁，而该锁正被其他线程持有；
        4>线程在等待某个触发条件；

6. 守护线程与非守护线程(Test05
    Java中有两种线程：用户线程、守护线程
    - 用户线程：用户自定义创建的线程，主线程停止，用户线程不会停止
    - 守护线程：当进程不存在或主线程停止，守护线程也会被停止。
      使用setDaemon(true)方法设置为守护线程

7. join()(Test06
    当在主线程当中执行到t1.join()方法时，则主线程把执行权让给t1；子线程执行完毕后，主线程才能执行

8. 线程优先级Priority（Test07
    通过一个int priority来控制优先级，范围为1-10，其中10最高，默认值为5。
    不代表每次都一定会被执行。 只是CPU调度会有限分配

9. yield()
    让具有相同优先级的线程之间能够适当的轮换执行。但不能保证yield()达到让步的目的（让步的线程可能被线程调度程序再次选中）