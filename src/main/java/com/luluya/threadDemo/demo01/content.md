#多线程基础#
0. 线程与进程的区别
    进程：是所有线程的集合，每一个线程是进程中的一条执行路径。
    线程：基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。

    大量的线程,会影响性能（操作系统需要在它们之间切换，更多的线程需要更多的内存空间，线程的中止需要考虑其对程序运行的影响。
    通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生。

1. 多线程应用场景
    作用：提高程序效率（eg:迅雷多线程下载、数据库连接池、分批发送短信等

2. 线程创建方式：
    a. 继承thread创建线程(ThreadDemo
        重写run方法（开启线程不是调用run方法，而是start方法
    b. 实现runnable创建线程(Runnable
        重写run方法（开启线程不是调用run方法，而是start方法
        *_实现Runnable接口好（实现了接口还可继续继承
        调用start():启动线程
        调用run():使用实例调用方法
    c. 实现匿名内部类创建线程(Test03
    d. 实现Callable创建线程(CallableDemo
       继承Thread类/实现Runnable接口: 
           缺点: 在线程任务执行结束后，无法获取执行结果(采用共享变量或共享存储区以及线程通信的方式实现获得任务结果的目的)

       Callable问题点：单独使用Callable，无法在新线程中(new Thread(Runnable r))使用，Thread 类只支持 Runnable。
                      不过 Callable 可以使用 ExecutorService
       
       使用Callable和Future来实现获取任务结果的操作
           Callable用来执行任务，产生结果
           Future用来获得结果（可以返回装载有计算结果）
       
       Future：必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。
       Future常用方法:
           V get() ：获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。
           V get(Long timeout , TimeUnit unit) ：获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。
           boolean isDone() ：如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。
           boolean isCanceller() ：如果任务完成前被取消，则返回true。
           boolean cancel(boolean mayInterruptRunning) ：(mayInterruptRunning参数表示是否中断执行中的线程)
               如果任务还没开始，执行cancel(...)方法将返回false；
               如果任务已经启动，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果停止成功，返回true；
               当任务已经启动，执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回false；
               当任务已经完成，执行cancel(...)方法将返回false
       
       通过方法分析我们也知道实际上Future提供了3种功能：
       （1）能够中断执行中的任务
       （2）判断任务是否执行完成
       （3）获取任务执行完成后的结果。
       
       FutureTask：实现了RunnableFuture接口（RunnableFuture继承了Runnable接口和Future接口）
            既可作为Runnable被线程执行，又可作为Future得到Callable的返回值。
            在并发的环境下，通过FutureTask作为中间转换，成功实现了让某个方法只被一个线程执行。

5. 多线程五种状态
    新建状态、就绪状态、运行状态、阻塞状态、死亡状态
    a. 新建状态：new Thread(r)
        此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码
    b. 就绪状态：start()
        当线程对象调用start()方法即启动了线程，
        start()方法创建线程运行的系统资源，并调度线程运行run()方法。
        当start()方法返回后，线程就处于就绪状态。
    c. 运行状态：run()
        当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.
    d. 死亡状态：
        产生原因：
        1)run方法正常退出而自然死亡，
        2)一个未捕获的异常终止了run方法而使线程猝死。
        为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。
        如果是可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的，或者线程死亡了，则返回false。
    e. *阻塞状态：
        产生原因：
        1>线程通过调用sleep方法进入睡眠状态；
        2>线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；
        3>线程试图得到一个锁，而该锁正被其他线程持有；
        4>线程在等待某个触发条件；

6. 守护线程与非守护线程(Test05
    Java中有两种线程：用户线程、守护线程
    - 用户线程：用户自定义创建的线程，主线程停止，用户线程不会停止
    - 守护线程：当进程不存在或主线程停止，守护线程也会被停止。
      使用setDaemon(true)方法设置为守护线程

7. join()(Test06
    当在主线程当中执行到t1.join()方法时，则主线程把执行权让给t1；子线程执行完毕后，主线程才能执行

8. 线程优先级Priority（Test07
    通过一个int priority来控制优先级，范围为1-10，其中10最高，默认值为5。
    不代表每次都一定会被执行。 只是CPU调度会有限分配

9. yield()
    让具有相同优先级的线程之间能够适当的轮换执行。但不能保证yield()达到让步的目的（让步的线程可能被线程调度程序再次选中）